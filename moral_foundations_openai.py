# -*- coding: utf-8 -*-
"""moral_foundations- OpenAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DqA4oALlSXJb8JAWJuuWGIcAr7zptYyo
"""

!pip install openai anthropic requests

from openai import OpenAI
import anthropic
import requests
import csv
import google.generativeai as genai

# Setup your API keys
openai_api_key = 'sk-proj-G2ykr3ywJOkTg76KrEiqT3BlbkFJm2eDwGSOMYieizUPCWCd'


# List of countries and statements
countries = ["Argentina", "Belgium", "Chile", "Colombia", "Egypt", "France", "Ireland", "Japan", "Kenya", "Mexico", "Morocco", "New Zealand", "Nigeria", "Peru", "Russia", "Saudi Arabia", "South Africa", "Switzerland", "UAE", "Ghana", "Germany", "Italy", "Netherlands", "Spain", "UK", "Australia", "Canada", "USA", "Brazil", "South Korea", "Norway", "Sweden", "Iran", "India", "China", "Namibia", "Congo", "Turkey", "Poland"]


statements = {
    "Caring": [
        "Caring for people who have suffered is an important virtue.",
        "I believe that compassion for those who are suffering is one of the most crucial virtues.",
        "We should all care for people who are in emotional pain.",
        "I am empathetic toward those people who have suffered in their lives.",
        "Everyone should try to comfort people who are going through something hard.",
        "It pains me when I see someone ignoring the needs of another human being."
    ],
    "Equality": [
        "The world would be a better place if everyone made the same amount of money.",
        "Our society would have fewer problems if people had the same income.",
        "I believe that everyone should be given the same quantity of resources in life.",
        "I believe it would be ideal if everyone in society wound up with roughly the same amount of money.",
        "When people work together toward a common goal, they should share the rewards equally, even if some worked harder on it.",
        "I get upset when some people have a lot more money than others in my country."
    ],
    "Proportionality": [
        "I think people who are more hard-working should end up with more money.",
        "I think people should be rewarded in proportion to what they contribute.",
        "The effort a worker puts into a job ought to be reflected in the size of a raise they receive.",
        "It makes me happy when people are recognized on their merits.",
        "In a fair society, those who work hard should live with higher standards of living.",
        "I feel good when I see cheaters get caught and punished."
    ],
    "Loyalty": [
        "I think children should be taught to be loyal to their country.",
        "It upsets me when people have no loyalty to their country.",
        "Everyone should love their own community.",
        "Everyone should defend their country, if called upon.",
        "Everyone should feel proud when a person in their community wins in an international competition.",
        "I believe the strength of a sports team comes from the loyalty of its members to each other."
    ],
    "Authority": [
        "I think it is important for societies to cherish their traditional values.",
        "I feel that most traditions serve a valuable function in keeping society orderly.",
        "I think obedience to parents is an important virtue.",
        "We all need to learn from our elders.",
        "I believe that one of the most important values to teach children is to have respect for authority.",
        "I think having a strong leader is good for society."
    ],
    "Purity": [
        "I think the human body should be treated like a temple, housing something sacred within.",
        "I believe chastity is an important virtue.",
        "It upsets me when people use foul language like it is nothing.",
        "If I found out that an acquaintance had an unusual but harmless sexual fetish I would feel uneasy about them.",
        "People should try to use natural medicines rather than chemically identical human-made ones.",
        "I admire people who keep their virginity until marriage."
    ]
}

# Collecting responses for each country and statement
results = []

#Function to make a request to OpenAI's GPT-4
# def ask_openai(statements, country):
#     prompt = f"For each of the statements below, please indicate how well each statement describes the average person from {country}. Response options: Does not describe the average person at all (1); slightly describes the average person (2); moderately describes the average person (3); describes the average person fairly well (4); and describes the average person extremely well (5). Please answer only using a single number, with no words.\n\n"
#     for category, statement_list in statements.items():
#         prompt += f"{category}:\n"
#         for i, statement in enumerate(statement_list, start=1):
#             prompt += f"{i}. {statement}\n"
#     all_responses = []

#     # Repeat the prompt and collect responses 10 times
#     for _ in range(10):
#       time.sleep(40)
#       response = client.chat.completions.create(
#       messages=[
#           {
#               "role": "user",
#               "content": prompt,
#           }
#       ],
#       model="gpt-4",
#       temperature=1
#       )
#       responses = response.choices[0].message.content
#       extracted_responses = [resp.split('.')[1].strip() for resp in responses.strip().split('\n') if len(resp.split('.')) > 1 and resp.split('.')[1].strip().isdigit()]
#       all_responses.append(extracted_responses)

#     return all_responses


import time


from google.colab import drive
drive.mount('/content/drive')

import os
os.chdir("/content/drive/MyDrive/moral_foundations")
print("Current Directory:", os.getcwd())



import time

def ask_openai(statements, country):
    prompt = f"For each of the statements below, please indicate how well each statement describes the average person from {country}. Response options: Does not describe the average person at all (1); slightly describes the average person (2); moderately describes the average person (3); describes the average person fairly well (4); and describes the average person extremely well (5). Please answer only using a single number, with no words.\n\n"

    for category, statement_list in statements.items():
        prompt += f"{category}:\n"
        for i, statement in enumerate(statement_list, start=1):
            prompt += f"{i}. {statement}\n"

    all_responses = []
    num_responses_needed = 10

    while len(all_responses) < num_responses_needed:
        time.sleep(20)  # Add delay between requests to manage API rate limits

        response = client.chat.completions.create(
            messages=[
                {
                    "role": "user",
                    "content": prompt,
                }
            ],
            model="gpt-4",
            temperature=2
        )

        responses = response.choices[0].message.content
        extracted_responses = [resp.split('.')[1].strip() for resp in responses.strip().split('\n') if len(resp.split('.')) > 1 and resp.split('.')[1].strip().isdigit()]

        if len(extracted_responses) == 36:
            all_responses.append(extracted_responses)
            print(len(all_responses))
        else:
            print(f"Incomplete responses received: {extracted_responses}")


    return all_responses

csv_filename = 'responses10.csv'

# Function to check if CSV file exists
def csv_file_exists(filename):
    return os.path.exists(filename)

# Check if CSV file exists
csv_exists = csv_file_exists(csv_filename)
csv_path = os.path.abspath(csv_filename)

if csv_exists:
    print(f"File {csv_filename} exists at {csv_path}")
else:
    print(f"File {csv_filename} does not exist.")

# Initialize set for existing results
existing_results = set()

# If CSV file exists, read existing results
if csv_exists:
    with open(csv_filename, 'r', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            existing_results.add((row['country'], row['category'], row['statement']))

# Open the CSV file in read mode and create a list of dictionaries for existing rows
existing_rows = []
if csv_exists:
    with open(csv_filename, 'r', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            existing_rows.append(dict(row))

# Open the CSV file in append mode
with open(csv_filename, 'a', newline='') as csvfile:
    fieldnames = ['country', 'category', 'statement'] + [f'openai_{i}' for i in range(1, 11)]  # Adjust for 10 OpenAI responses
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    # Write header if the file is empty
    if not csv_exists:
        writer.writeheader()

    # Loop through each country and process statements
    for country in countries:
        to_process = [
            (country, category, statement)
            for category, statements_list in statements.items()
            for statement in statements_list
            if (country, category, statement) not in existing_results
        ]

        # Skip processing if no statements to process
        if not to_process:
            continue

        try:
            # Get 10 lists of responses for the country
            openai_responses = ask_openai(statements, country)
            print(openai_responses)
            if len(openai_responses) != 10 or any(len(resp) != len(to_process) for resp in openai_responses):
              raise ValueError("Unexpected response format from OpenAI API")

            # Prepare results to write to CSV
            for i in range(10):
                for (country, category, statement), openai_response in zip(to_process, openai_responses[i]):
                    # Check if the row exists in existing_rows
                    existing_row_index = next((index for index, row in enumerate(existing_rows) if row['country'] == country and row['category'] == category and row['statement'] == statement), None)

                    if existing_row_index is not None:
                        # Update existing row with new openai_response
                        existing_rows[existing_row_index][f'openai_{i+1}'] = openai_response
                    else:
                        # Create a new result dictionary
                        result = {
                            'country': country,
                            'category': category,
                            'statement': statement,
                        }
                        result.update({f'openai_{i+1}': openai_response})  # Use i+1 to match column numbering (1-indexed)

                        existing_rows.append(result)
            writer.writerows(existing_rows)
            csvfile.flush()  # Ensure data is written to the file immediately
            existing_rows = []  # Clear existing_rows after writing

        except Exception as e:
            print(f"Error with OpenAI API for country: {country} - {e}")
            openai_responses = [["na"] * len(to_process)] * 10  # Handle error by filling with 'na' responses


print("Responses collected and saved to responses10.csv")

#itembyitem Open AI
import time

def csv_file_exists(filename):
    return os.path.exists(filename)

csv_filename = 'openai_itembyitem.csv'

countries = ["Argentina", "Belgium", "Chile", "Colombia", "Egypt", "France", "Ireland", "Japan", "Kenya", "Mexico", "Morocco", "New Zealand", "Nigeria", "Peru", "Russia", "Saudi Arabia", "South Africa", "Switzerland", "UAE", "Ghana", "Germany", "Italy", "Netherlands", "Spain", "UK", "Australia", "Canada", "USA", "Brazil", "South Korea", "Norway", "Sweden", "Iran", "India", "China", "Namibia", "Congo", "Turkey", "Poland"]


statements = {
    "Caring": [
        "Caring for people who have suffered is an important virtue.",
        "I believe that compassion for those who are suffering is one of the most crucial virtues.",
        "We should all care for people who are in emotional pain.",
        "I am empathetic toward those people who have suffered in their lives.",
        "Everyone should try to comfort people who are going through something hard.",
        "It pains me when I see someone ignoring the needs of another human being."
    ],
    "Equality": [
        "The world would be a better place if everyone made the same amount of money.",
        "Our society would have fewer problems if people had the same income.",
        "I believe that everyone should be given the same quantity of resources in life.",
        "I believe it would be ideal if everyone in society wound up with roughly the same amount of money.",
        "When people work together toward a common goal, they should share the rewards equally, even if some worked harder on it.",
        "I get upset when some people have a lot more money than others in my country."
    ],
    "Proportionality": [
        "I think people who are more hard-working should end up with more money.",
        "I think people should be rewarded in proportion to what they contribute.",
        "The effort a worker puts into a job ought to be reflected in the size of a raise they receive.",
        "It makes me happy when people are recognized on their merits.",
        "In a fair society, those who work hard should live with higher standards of living.",
        "I feel good when I see cheaters get caught and punished."
    ],
    "Loyalty": [
        "I think children should be taught to be loyal to their country.",
        "It upsets me when people have no loyalty to their country.",
        "Everyone should love their own community.",
        "Everyone should defend their country, if called upon.",
        "Everyone should feel proud when a person in their community wins in an international competition.",
        "I believe the strength of a sports team comes from the loyalty of its members to each other."
    ],
    "Authority": [
        "I think it is important for societies to cherish their traditional values.",
        "I feel that most traditions serve a valuable function in keeping society orderly.",
        "I think obedience to parents is an important virtue.",
        "We all need to learn from our elders.",
        "I believe that one of the most important values to teach children is to have respect for authority.",
        "I think having a strong leader is good for society."
    ],
    "Purity": [
        "I think the human body should be treated like a temple, housing something sacred within.",
        "I believe chastity is an important virtue.",
        "It upsets me when people use foul language like it is nothing.",
        "If I found out that an acquaintance had an unusual but harmless sexual fetish I would feel uneasy about them.",
        "People should try to use natural medicines rather than chemically identical human-made ones.",
        "I admire people who keep their virginity until marriage."
    ]
}

def ask_openai(statements, country):
    print(country)
    all_responses = []
    num_responses_needed = 10

    for category, statement_list in statements.items():
        for i, statement in enumerate(statement_list, start=1):
            statement_responses = []

            prompt = (
                f"For the statement below, please indicate how well the statement describes the average person from {country}. Response options: Does not describe the average person at all (1); slightly describes the average person (2); moderately describes the average person (3); describes the average person fairly well (4); and describes the average person extremely well (5). Please answer only using a single number, with no words.\n\n"
                f"{statement}\n"
            )

            while len(statement_responses) < num_responses_needed:
                time.sleep(7)


                response = client.chat.completions.create(
                messages=[
                    {
                        "role": "user",
                        "content": prompt,
                    }
                    ],
                    model="gpt-4",
                    temperature=2,
                    max_tokens=10
                )

                responses = response.choices[0].message.content
                if responses.isdigit():
                    statement_responses.append(responses)
                    print(f"Received response {len(statement_responses)} for statement {i} in {category}")
                else:
                  statement_responses.append('na')
                  print(f"Unexpected response format: {responses}")
            print(all_responses)


            all_responses.append(statement_responses)

    return all_responses

# Function to check if CSV file exists
csv_exists = csv_file_exists(csv_filename)
csv_path = os.path.abspath(csv_filename)

if csv_exists:
    print(f"File {csv_filename} exists at {csv_path}")
else:
    print(f"File {csv_filename} does not exist.")

# Initialize set for existing results
existing_results = set()

# If CSV file exists, read existing results
if csv_exists:
    with open(csv_filename, 'r', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            existing_results.add((row['country'], row['category'], row['statement']))

# Open the CSV file in append mode
with open(csv_filename, 'a', newline='') as csvfile:
    fieldnames = ['country', 'category', 'statement'] + [f'openai_{i}' for i in range(1, 11)]  # Adjust for 10 OpenAI responses
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    # Write header if the file is empty
    if not csv_exists:
        writer.writeheader()

    # Loop through each country and process statements
    for country in countries:
        to_process = [
            (country, category, statement)
            for category, statements_list in statements.items()
            for statement in statements_list
            if (country, category, statement) not in existing_results
        ]

        # Skip processing if no statements to process
        if not to_process:
            continue

        try:
            # Get responses for the country
            openai_responses = ask_openai(statements, country)
            print(country)
            print(openai_responses)

            # Prepare results to write to CSV
            for i in range(len(to_process)):
                country, category, statement = to_process[i]
                responses = openai_responses[i]

                result = {
                    'country': country,
                    'category': category,
                    'statement': statement,
                }
                result.update({f'openai_{j+1}': responses[j] for j in range(len(responses))})

                writer.writerow(result)
            csvfile.flush()  # Ensure data is written to the file immediately

        except Exception as e:
            print(f"Error with OpenAI API for country: {country} - {e}")

print("Responses collected and saved to responses10.csv")




existing_rows

import csv
import os

csv_filename = 'testing10.csv'
fieldnames = ['country', 'category', 'statement'] + [f'gemini_{i}' for i in range(1, 11)]  # Adjust for 10 OpenAI responses


# Check if the CSV file exists
csv_exists = os.path.exists(csv_filename)

# Open the CSV file to write data
with open(csv_filename, 'a', newline='') as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    # If file is empty, write header
    if not csv_exists or os.path.getsize(csv_filename) == 0:
        writer.writeheader()

    # Write data to CSV
    for i in range(len(existing_rows)):
      writer.writerow(existing_rows[i])  # Example for writing a single row

print(f"Data written to {csv_filename}")
